<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Illusion World — Isometric & Escher Modes (Annotated)</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
<style>
  body { margin:0; background:#0b1018; color:#e6eefc; font-family: monospace; }
  .hud {
    position: fixed; inset: 12px auto auto 12px; z-index: 10;
    background: rgba(8,12,20,0.88); border:1px solid #1a2233; padding:10px 12px; border-radius:10px;
    display:flex; gap:8px; align-items:center;
  }
  .hud button {
    padding:6px 10px; border-radius:8px; border:1px solid #2a3650;
    background:#121a27; color:#e6eefc; cursor:pointer;
  }
  .hud button:hover { background:#172235; }
</style>
<style>
  /* Fade-in for HUD controls */
  @keyframes hudFadeIn {
    from { opacity: 0; transform: translateY(-12px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .hud {
    animation: hudFadeIn 1.2s ease-out;
  }
</style>

</head>
<body>

<div class="hud">
  <button id="regenBtn">Regenerate (R)</button>
  <button id="geomBtn">Mode: <span id="geomMode">Isometric</span></button>
  <button id="aiBtn">AI Mutate (A)</button>
  <button id="palBtn">Palette: <span id="palName">Natural</span></button>
</div>

<script>
/*
=========================================================
Illusion World (Isometric & Escher Modes)
Author: Steve Cross & ChatGPT (collaborative demo)
=========================================================
✔ Generates terrain via Wave Function Collapse–like rules
✔ R key: regenerate world
✔ G key: toggle geometry (isometric ↔ Escher loop)
✔ A key: AI mutation (changes palette & rules)
✔ P key: cycle color palettes
=========================================================
*/

//--------------------------------------------
// Scene Class: main logic and rendering
//--------------------------------------------
class IllusionWorld extends Phaser.Scene {
  constructor() { super("IllusionWorld"); }

  create() {
    // --- Core map dimensions ---
    this.cols = 28;       // number of tiles across
    this.rows = 18;       // number of tiles down
    this.isoW = 40;       // width of diamond tile (top face)
    this.isoH = 20;       // height of diamond tile
    this.blockZ = 12;     // side wall height (illusion of depth)

    // --- Modes ---
    this.modes = ["iso", "escher"];
    this.modeIndex = 0;
    this.mode = this.modes[this.modeIndex];

    // --- Terrain categories & adjacency rules ---
    this.cats = ["water","sand","grass","forest","rock"];
    this.rules = {
      water:  ["water","sand"],
      sand:   ["water","sand","grass"],
      grass:  ["sand","grass","forest"],
      forest: ["grass","forest","rock"],
      rock:   ["forest","rock"]
    };

    // --- Color palettes ---
    this.palettes = [
      { name:"Natural", colors:{water:0x3aa0ff, sand:0xe8d39a, grass:0x6fcf70, forest:0x2f8a4e, rock:0x9a9ea6} },
      { name:"Dream",   colors:{water:0x7ea6ff, sand:0xffd8a8, grass:0xa3ffbe, forest:0x74d68c, rock:0xb5b9ff} },
      { name:"Shadow",  colors:{water:0x4b7bbd, sand:0xbda977, grass:0x4f8f59, forest:0x2f5f42, rock:0x6f7683} }
    ];
    this.paletteIndex = 0;
    this.palette = {...this.palettes[this.paletteIndex].colors};

    // --- UI bindings ---
    this.g = this.add.graphics();
    this.hudGeom = document.getElementById("geomMode");
    this.hudPal  = document.getElementById("palName");
    this.hudGeom.textContent = "Isometric";
    this.hudPal.textContent  = this.palettes[0].name;

    // --- Buttons & hotkeys ---
    document.getElementById("regenBtn").onclick = () => this.regenerate();
    document.getElementById("geomBtn").onclick  = () => this.toggleMode();
    document.getElementById("aiBtn").onclick    = () => this.aiMutate();
    document.getElementById("palBtn").onclick   = () => this.cyclePalette();

    this.input.keyboard.on("keydown-R", () => this.regenerate());
    this.input.keyboard.on("keydown-G", () => this.toggleMode());
    this.input.keyboard.on("keydown-A", () => this.aiMutate());
    this.input.keyboard.on("keydown-P", () => this.cyclePalette());

    this.regenerate(); // initial generation
  }

  //--------------------------------------------
  // WFC-like generation logic
  //--------------------------------------------
  regenerate() {
    this.catMap = this.solveCategories();
    this.heightMap = this.buildHeightMap();
    this.renderWorld();
  }

  solveCategories() {
    // local propagation similar to WFC: each tile constrained by neighbors
    const W = this.cols, H = this.rows;
    const out = Array.from({length:H}, _ => Array(W).fill("grass"));

    for (let y=0; y<H; y++) {
      for (let x=0; x<W; x++) {
        let c = this.pickCategory(x,y);
        // constrain horizontally & vertically
        if (x>0) c = this.constrain(c, out[y][x-1]);
        if (y>0) c = this.constrain(c, out[y-1][x]);
        out[y][x] = c;
      }
    }
    return out;
  }

  pickCategory(x,y) {
    // Noise bias: water at edges, rock inland
    const r = this.hash2(x*0.15, y*0.12);
    if (r < 0.15) return "water";
    if (r < 0.3) return "sand";
    if (r < 0.7) return "grass";
    if (r < 0.88) return "forest";
    return "rock";
  }

  constrain(chosen, neighbor) {
    const allowed = this.rules[neighbor];
    if (!allowed) return chosen;
    if (allowed.includes(chosen)) return chosen;
    return Phaser.Utils.Array.GetRandom(allowed);
  }

  //--------------------------------------------
  // Escher-like height wrapping
  //--------------------------------------------
  buildHeightMap() {
    const W=this.cols, H=this.rows;
    const hm = Array.from({length:H}, _ => Array(W).fill(0));
    for (let y=0; y<H; y++) {
      for (let x=0; x<W; x++) {
        const slope = (x+y)*0.3; // diagonal climb
        const noise = this.hash2(x*0.12, y*0.17)*2.0;
        hm[y][x] = slope + noise;
      }
    }
    // wrap edges to create the illusion of endless ascent
    const wrap = 6.0;
    for (let x=0; x<W; x++) { hm[0][x]    = hm[H-1][x] + wrap; }
    for (let y=0; y<H; y++) { hm[y][0]    = hm[y][W-1] + wrap; }
    return hm;
  }

  //--------------------------------------------
  // Rendering
  //--------------------------------------------
  renderWorld() {
    this.g.clear();
    const useEscher = (this.mode === "escher");
    this.drawIso(useEscher);
  }

  drawIso(useEscher) {
    const g=this.g, W=this.cols, H=this.rows;
    const isoW=this.isoW, isoH=this.isoH, Z=this.blockZ;
    const cx0 = this.scale.gameSize.width/2, cy0=100;
    const isoX = (x,y) => cx0 + (x - y) * (isoW/2);
    const isoY = (x,y) => cy0 + (x + y) * (isoH/2);

    for (let y=0; y<H; y++) {
      for (let x=0; x<W; x++) {
        const cat = this.catMap[y][x];
        const base = this.palette[cat];
        const topCol   = this.shade(base, +0.1);
        const leftCol  = this.shade(base, -0.1);
        const rightCol = this.shade(base, -0.2);
        let cx = isoX(x,y), cy = isoY(x,y);
        let lift = useEscher ? this.heightMap[y][x] : 0;
        cy -= lift;

        // --- top face ---
        g.fillStyle(topCol,1);
        g.beginPath();
        g.moveTo(cx, cy - isoH/2);
        g.lineTo(cx + isoW/2, cy);
        g.lineTo(cx, cy + isoH/2);
        g.lineTo(cx - isoW/2, cy);
        g.closePath(); g.fillPath();

        // --- left face ---
        g.fillStyle(leftCol,1);
        g.beginPath();
        g.moveTo(cx - isoW/2, cy);
        g.lineTo(cx, cy + isoH/2);
        g.lineTo(cx, cy + isoH/2 + Z);
        g.lineTo(cx - isoW/2, cy + Z);
        g.closePath(); g.fillPath();

        // --- right face ---
        g.fillStyle(rightCol,1);
        g.beginPath();
        g.moveTo(cx + isoW/2, cy);
        g.lineTo(cx, cy + isoH/2);
        g.lineTo(cx, cy + isoH/2 + Z);
        g.lineTo(cx + isoW/2, cy + Z);
        g.closePath(); g.fillPath();
      }
    }
  }

  //--------------------------------------------
  // AI mutation: small random color & rule changes
  //--------------------------------------------
  aiMutate() {
    const jitter = () => Phaser.Math.FloatBetween(-0.10, 0.10);
    const mutateColor = (hex) => {
      const c = Phaser.Display.Color.IntegerToColor(hex);
      let hsv = Phaser.Display.Color.RGBToHSV(c.red, c.green, c.blue);
      hsv.h = (hsv.h + jitter() + 1.0) % 1.0;
      hsv.s = Phaser.Math.Clamp(hsv.s + jitter()*0.5, 0.3, 1.0);
      hsv.v = Phaser.Math.Clamp(hsv.v + jitter()*0.4, 0.4, 1.0);
      const rgb = Phaser.Display.Color.HSVToRGB(hsv.h, hsv.s, hsv.v);
      return Phaser.Display.Color.GetColor(rgb.r, rgb.g, rgb.b);
    };
    for (const k of Object.keys(this.palette)) this.palette[k] = mutateColor(this.palette[k]);
    this.renderWorld();
  }

  //--------------------------------------------
  // Palette switching
  //--------------------------------------------
  cyclePalette() {
    this.paletteIndex = (this.paletteIndex + 1) % this.palettes.length;
    this.palette = {...this.palettes[this.paletteIndex].colors};
    document.getElementById("palName").textContent = this.palettes[this.paletteIndex].name;
    this.renderWorld();
  }

  toggleMode() {
    this.modeIndex = (this.modeIndex + 1) % this.modes.length;
    this.mode = this.modes[this.modeIndex];
    document.getElementById("geomMode").textContent =
      (this.mode === "iso") ? "Isometric" : "Escher";
    this.renderWorld();
  }

  //--------------------------------------------
  // Utility: shading & noise
  //--------------------------------------------
  shade(hex, delta) {
    const c = Phaser.Display.Color.IntegerToColor(hex);
    let hsv = Phaser.Display.Color.RGBToHSV(c.red, c.green, c.blue);
    hsv.v = Phaser.Math.Clamp(hsv.v + delta, 0, 1);
    const rgb = Phaser.Display.Color.HSVToRGB(hsv.h, hsv.s, hsv.v);
    return Phaser.Display.Color.GetColor(rgb.r, rgb.g, rgb.b);
  }

  hash2(x,y) {
    const s = Math.sin(x*12.9898 + y*78.233)*43758.5453;
    return s - Math.floor(s);
  }
}

//--------------------------------------------
// Phaser initialization
//--------------------------------------------
new Phaser.Game({
  type: Phaser.AUTO,
  width: 1200,
  height: 860,
  backgroundColor: "#0b1018",
  scene: IllusionWorld
});

/*
=========================================================
Reflection Summary
=========================================================
Concepts Demonstrated:
1. Procedural WFC logic (local constraint propagation)
2. Isometric projection via diamond tiling
3. Escher illusion using height wrapping
4. AI mutation for color and rule exploration
5. Human–AI mixed initiative: user interprets, AI mutates
=========================================================
*/
</script>
<!-- signature caption -->
<div class="signature">
  Illusion World — Steve Cross (2025)
</div>

<style>
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to   { opacity: 0.75; transform: translateY(0); }
  }

  .signature {
    position: fixed;
    right: 12px;
    bottom: 10px;
    color: #9fb8ff;
    font-family: "Courier New", monospace;
    font-size: 13px;
    letter-spacing: 0.5px;
    opacity: 0.75;
    text-shadow: 0 0 6px rgba(150,180,255,0.6);
    user-select: none;
    pointer-events: none;
    animation: fadeIn 1.5s ease-out;
  }
</style>
<!-- centered title intro -->
<div id="titleIntro">Illusion&nbsp;World</div>

<style>
  /* Background gradient animation for cinematic effect */
  @keyframes bgShift {
    0%   { background: radial-gradient(circle at center, #0a0d17 0%, #060910 80%); }
    50%  { background: radial-gradient(circle at center, #0e1322 0%, #0a0f1a 80%); }
    100% { background: radial-gradient(circle at center, #0b1018 0%, #060912 80%); }
  }

  @keyframes titleFade {
    0%   { opacity: 0; }
    10%  { opacity: 1; }
    70%  { opacity: 1; }
    100% { opacity: 0; visibility: hidden; }
  }

  #titleIntro {
    position: fixed;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: "Courier New", monospace;
    font-size: 48px;
    color: #b0c4ff;
    text-shadow: 0 0 14px rgba(150,180,255,0.8);
    background: radial-gradient(circle at center, #0b1018 0%, #060912 80%);
    opacity: 0;
    animation:
      titleFade 3s ease-in-out forwards,
      bgShift 3.5s ease-in-out forwards;
    z-index: 20;
  }
</style>

<script>
  // Remove the intro overlay after animation ends
  setTimeout(() => {
    const t = document.getElementById("titleIntro");
    if (t) t.remove();
  }, 3500);
</script>

</body>
</html>

